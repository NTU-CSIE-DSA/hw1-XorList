\setcounter{secnumdepth}{0}

\subsection{Problem Description}\label{problem-description}

Doubly-linked lists are convenient, but come with two disadvantages. Firstly, two pointers are used per node instead of one, making it hard to fit small-cache/memory scenarios. Secondly, reversing a doubly-linked list typically requires swapping the \texttt{next} and \texttt{prev} pointers of every node, making it less efficient for applications with frequent reversal needs.

The XOR linked list is here for rescue! In this problem, we ask you to implement the usual doubly-linked list and the XOR linked list. The following description of the XOR linked list is quoted from Wikipedia (\url{https://en.wikipedia.org/wiki/XOR_linked_list}): 

{\it
An XOR linked list is a type of data structure used in computer programming. It takes advantage of the bitwise XOR operation to decrease storage requirements for doubly linked lists by storing the composition of both addresses in one field. While the composed address is not meaningful on its own, during traversal it can be combined with knowledge of the last-visited node address to deduce the address of the following node.
}

\subsubsection{9.h}\label{9.h}

Detailed header file \texttt{9.h} is provided in the judge system.

\noindent \texttt{Node} is a structure that stores the information of a node in XOR linked list. \texttt{head} and \texttt{tail} are the variables represent the head and the tail of the XOR linked list. \texttt{node\_count} represents the upcoming count of nodes in the XOR linked list if the next node is inserted.

We provide 2 well-implemented functions for students to utilize.

\begin{codebox}
\Procname{$\proc{Next-Node}(node, prev)$}
\li \Return $\attrib{node}{neighbors} \oplus prev$
\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{New-XOR-Node}(data, neighbors)$}
\li initialize $newNode$
\li \Return $newNode$
\End
\end{codebox}

We assume $data$ to be an integer that represents the number of $\textsc{New-XOR-Node}$ calls so far. That is, the first new node will contain $data = 1$, the second new node will contain $data = 2$, and so on.

\textbf{In this problem, you need to implement 3 routines and 7 types of operations which are defined in the header file \texttt{9.h}.}

Here are the 3 routines that we ask you to implement:

\begin{codebox}
\Procname{$\proc{Insert-After}(node, prev, data)$}
\li $next \gets \proc{Next-Node}(node, prev)$
\li $newNode \gets \textsc{New-XOR-Node}(data, next \oplus node)$
\li $\attrib{next}{neighbors} \gets \attrib{next}{neighbors} \oplus node \oplus newNode$
\li $\attrib{node}{neighbors} \gets prev \oplus newNode$
\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{Remove-Here}(node, prev)$}
\li $next \gets \proc{Next-Node}(node, prev)$
\li $\attrib{prev}{neighbors} \gets \attrib{prev}{neighbors} \oplus node \oplus next$
\li $\attrib{next}{neighbors} \gets \attrib{next}{neighbors} \oplus node \oplus prev$
\li $\proc{Free}(node)$
\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{Reverse}(prev, begin, end, next)$}
\li $\attrib{prev}{neighbors} \gets \attrib{prev}{neighbors} \oplus begin \oplus end$
\li $\attrib{begin}{neighbors} \gets \attrib{begin}{neighbors} \oplus prev \oplus next$
\li $\attrib{end}{neighbors} \gets \attrib{end}{neighbors} \oplus next \oplus prev$
\li $\attrib{next}{neighbors} \gets \attrib{next}{neighbors} \oplus end \oplus begin$
\End
\end{codebox}

\begin{itemize}
    \item $\textsc{Insert-After}(node, prev, data)$ is for inserting a node \texttt{newNode} with $data$ after the node \texttt{node}, where \texttt{prev} is the previous node of \texttt{node}.
    \item $\textsc{Remove-Here}(node, prev)$ is for removing the node \texttt{node}, where \texttt{prev} is the previous node of \texttt{node}.
    \item $\textsc{Reverse}(prev, begin, end, next)$ is for reversing all the nodes in range \texttt{[begin, end]}, where \texttt{prev} is the previous node of \texttt{begin} and \texttt{next} is the next node of \texttt{end}.
\end{itemize}

Here are 7 types of operations that we ask you to implement:

\begin{itemize}
    \item $type\_0(k)$ is for printing out the $data$ field of the $k$-th node of the XOR linked list, where $k$ is $1$-indexed.
    \item $type\_1(data)$ is for calling $\proc{Insert-After}$ at the head of the XOR linked list, The new node will then become the first node of the linked list.
    \item $type\_2(k, data)$ is for calling $\proc{Insert-After}$ at the $k$-th node of the XOR linked list, where $k$ is $1$-indexed. The new node will then become the $(k+1)$-th node of the linked list.
    \item $type\_3(k, data)$ is for calling $\proc{Insert-After}$ at the $k$-th last node of the XOR linked list, where $k$ is $1$-indexed. The new node will then become the $k$-th last node of the linked list.
    \item $type\_4(k)$ is for calling $\proc{Remove-Here}$ at the $k$-th node of the XOR linked list, where $k$ is $1$-indexed.
    \item $type\_5(k)$ is for calling $\proc{Remove-Here}$ at the $k$-th last node of the XOR linked list, where $k$ is $1$-indexed. 
    \item $type\_6(k)$ is for calling $\proc{Reverse}$ from the $k$-th node of the XOR linked list to the $k$-th last node of the XOR linked list.
\end{itemize}

\textbf{You should only upload the file \texttt{9.c} and do not output anything to stdout.} Otherwise, you may get unexpected error. In addition, we strongly recommend you not to modify any parts other than the annotation at the very bottom. 

\subsubsection{9.c}\label{9.c}

Detailed \texttt{9.c} is provided in the judge system.

\noindent We will use the following command to compile your code:

\begin{center}
\texttt{gcc 9.c main.c -static -O2 -std=c11}
\end{center}

\noindent We will run \texttt{main.c} to test your code.

\subsubsection{main.c}\label{main.c}

Detailed \texttt{main.c} is provided in the judge system.

\subsection{Input}\label{input}

We assume initially the XOR linked list is empty. The first line includes one integers, $M$, representing the number of operation. The next $M$ lines include $2$ integers, $t$ and $k$. The first integer, $t$, represents the operation type. The second integer, $k$, represents the additional parameters for the operation.

\subsection{Output}\label{output}

For each type $0$ operation, print the value of the $data$ in the $k$-th node in one line.

\subsection{Constraints}\label{constraint}

\begin{itemize}
    \item $1\leq M\leq 5\times 10^5$
    \item $t\in 0, 1, 2, 3, 4, 5, 6$
    \item if $t\in 0, 2, 3, 4, 5$, $1\leq k\leq |L|$, where $|L|$ is the current length of the XOR linked list
    \item if $t\in 1$, $k=0$
    \item if $t\in 6$, $1\leq k\leq \lceil{\frac{|L|}{2}}\rceil$, where $|L|$ is the current length of the XOR linked list
    \item It is ensured that if the XOR linked list is currently empty, $t\in 1$
    \item $\sum k\leq 5\times 10^7$
\end{itemize}

\section*{Subtasks}
\subsubsection{Subtask 1 (10 pts)}\label{subtask-1}
\begin{itemize}
\item $t\in 0, 1$
\end{itemize}

\subsubsection{Subtask 2 (15 pts)}\label{subtask-2}
\begin{itemize}
\item $t\in 0, 1, 2$
\end{itemize}

\subsubsection{Subtask 3 (15 pts)}\label{subtask-3}
\begin{itemize}
\item $t\in 0, 1, 2, 3$
\end{itemize}

\subsubsection{Subtask 4 (20 pts)}\label{subtask-4}
\begin{itemize}
\item $t\in 0, 1, 2, 3, 4, 5$
\end{itemize}

\subsubsection{Subtask 5 (40 pts)}\label{subtask-5}
\begin{itemize}
\item $t\in 0, 1, 2, 3, 4, 5, 6$
\end{itemize}

\subsection{Sample Testcases}\label{sample-testcases}

\begin{multicols}{2}
\subsubsection{Sample Input 1}\label{sample-input-1}
\begin{verbatim}
6
1 0
1 0
0 1
0 2
1 0
0 3
\end{verbatim}

\columnbreak

\subsubsection{Sample Output 1}\label{sample-output-1}
\begin{verbatim}
2
1
1
\end{verbatim}
\end{multicols}

\begin{multicols}{2}
\subsubsection{Sample Input 2}\label{sample-input-2}
\begin{verbatim}
10
1 0
2 1
3 2
2 3
3 1
0 1
0 2
0 3
0 4
0 5
\end{verbatim}

\columnbreak

\subsubsection{Sample Output 2}\label{sample-output-2}
\begin{verbatim}
1 
3 
2 
4 
5
\end{verbatim}
\end{multicols}

\begin{multicols}{2}
\subsubsection{Sample Input 3}\label{sample-input-3}
\begin{verbatim}
11
1 0
2 1
3 2
2 3
3 1
6 2
4 1
5 3
0 1
0 2
0 3
\end{verbatim}
    
\columnbreak
    
\subsubsection{Sample Output 3}\label{sample-output-3}
\begin{verbatim}
4
3
5
\end{verbatim}
\end{multicols}

\subsection{Hints}\label{hints}

\subsubsection{Sample 1 Explanation}\label{sample-1-explanation}

After completing first two $type\_1$ operations, the \texttt{data} of the XOR linked list's nodes are: \\
$2\rightarrow 1$ \\
After completing the last $type\_1$ operation, the \texttt{data} of the XOR linked list's become: \\
$3\rightarrow 2\rightarrow 1$ \\
where the leftmost value refers to the \texttt{data} of the first node.

\subsubsection{Sample 3 Explanation}\label{sample-3-explanation}

After completing the $type\_6$ operation, the \texttt{data} of the XOR linked list's become: \\
$1\rightarrow 4\rightarrow 2\rightarrow 3\rightarrow 5$ \\
After completing the $type\_4$ and $type\_6$ operations, the \texttt{data} of the XOR linked list's become: \\
$4\rightarrow 3\rightarrow 5$
